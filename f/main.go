package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"strconv"
)

func main() {
	rdr := bufio.NewReader(os.Stdin)

	var n, m, val int
	_, _ = fmt.Fscanln(rdr, &n)

	counts := [100]int{}

	for lineIdx := 0; lineIdx < n; lineIdx++ {
		_, _ = fmt.Fscan(rdr, &m)

		for i := 0; i < m; i++ {
			_, _ = fmt.Fscan(rdr, &val)
			counts[val]++
		}
	}

	var buf bytes.Buffer
	var tmp [3]byte
	for val, cnt := range counts {
		if cnt == 0 {
			continue
		}

		valStr := strconv.AppendInt(tmp[:0], int64(val), 10)

		for i := 0; i < cnt; i++ {
			buf.Write(valStr)
			buf.WriteByte(' ')
		}
		_, _ = os.Stdout.Write(buf.Bytes())
		buf.Reset()
	}

	fmt.Println()
}

/*
Даны k отсортированных в порядке неубывания массивов неотрицательных целых чисел, каждое из которых не превосходит 100. Требуется построить результат их слияния: отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов.

Длина каждого массива не превосходит 10 ⋅ k.

Постарайтесь, чтобы решение работало за время k ⋅ log(k) ⋅ n, если считать, что входные массивы имеют длину n.

Формат ввода
Первая строка входного файла содержит единственное число k, k ≤ 1024.
Каждая из следующих k строк описывает по одному массиву. Первое число каждой строки равняется длине соответствующего массива, оставшиеся числа этой строки описывают значения элементов этого же массива. Элементы массивов являются неотрицательными целыми числами и не превосходят 100.

Формат вывода
Выходной файл должен содержать отсортированный в порядке неубывания массив, содержащий все элементы исходных массивов.

Ввод:
4
6 2 26 64 88 96 96
4 8 20 65 86
7 1 4 16 42 58 61 69
1 84

Вывод:
1 2 4 8 16 20 26 42
58 61 64 65 69 84 86
88 96 96
*/
